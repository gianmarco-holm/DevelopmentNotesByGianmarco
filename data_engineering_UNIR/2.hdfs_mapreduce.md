# HDFS (Hadoop Distributed File System) Y MAPREDUCE

## üóíÔ∏è HDFS

Es un sistema de archivos distribuido dise√±ado para almacenar y procesar grandes vol√∫menes de datos en cl√∫steres de computadoras y es parte del ecosistema de HADOOP.

Notas:

* Es un software: Escrito en Java que simula un sistema de archivos, pero por detr√°s se almacena archivos distribuidos.
* Archivos con acceso write-one, read-many: Que significa que solo nos permite escritura, lecturas y borrado, menos modificaci√≥n.
* Un cl√∫ster: es un conjunto de computadoras o nodos interconectadas que trabajan juntas como si fueran una sola unidad.

---

## üõ†Ô∏è Arquitectura de HDFS

### üß± Bloques de HDFS

En HDFS, los bloques son unidades l√≥gicas de almacenamiento dentro del sistema distribuido. A diferencia de los bloques f√≠sicos o sectores de un disco duro, que son administrados por el hardware y tienen tama√±os peque√±os (por ejemplo, 4 KB o 512 bytes), los bloques de HDFS suelen ser mucho m√°s grandes (por defecto 128 MB o 256 MB).

Diferencias clave:

* **Tama√±o:** Los bloques de HDFS son mucho m√°s grandes para optimizar la lectura y escritura en sistemas distribuidos.

* **Ubicaci√≥n:** HDFS distribuye sus bloques en varios nodos del cl√∫ster para mejorar la disponibilidad y la tolerancia a fallos, mientras que los bloques f√≠sicos est√°n en un solo disco.

* **Replicaci√≥n:** HDFS replica sus bloques en m√∫ltiples nodos (por defecto 3 copias) para evitar p√©rdida de datos, mientras que los bloques f√≠sicos no tienen esta redundancia a nivel de almacenamiento local.

> ‚öôÔ∏è Opcional: **Rack-awareness**, nos permite indicar que nodo pertenece a cada rack, y asi HDFS pueda decidir mejor en que nodo colocar cada bloque f√≠sico, por regla general no puede ir m√°s de una replica en el mismo nodo y m√°s de dos replicas en el mismo rack.

### üß± Datanode y Namenode

Cuando se instala HDFS en un cl√∫ster, cada nodo puede utilizarse como datanode o como namenode. El namenode (debe haber, al menos, uno) mantiene la estructura de directorios existentes y los metadatos asociados a cada archivo. Por su parte, los datanodes almacenan bloques de datos y los devuelven a petici√≥n del namenode o del programa cliente que est√° accediendo a HDFS para leer datos.

> üìå Nota: El **heartbeat** en HDFS es una se√±al peri√≥dica (por defecto 3 seg) que los DataNodes env√≠an al NameNode para informar que siguen activos y funcionando correctamente.

HDFS no puede funcionar sin en el namenode, es por ello que es recomendable **realizar una copia** o **tener un namenode secundario**.

* **Alta disponibilidad del namenode**

Se utilizan un par de namenodes, uno de ellos denominado activo y el otro en stand by. Ambos comparten un log de edici√≥n en un sistema de almacenamiento externo y que posee tambi√©n alta disponibilidad. El log va siendo modificado por el namenode activo, pero el namenode en stand by lo va leyendo y va aplicando esos cambios en sus propios metadatos, para estar siempre actualizado respecto al namenode activo. Los datanodes reportan la informaci√≥n a ambos para monitorizar el estado. En caso de fallo del namenode activo, el que se encontraba en stand by pasa inmediatamente a activo. Como se√±al√°bamos, estar√° actualizado, puesto que todas las operaciones realizadas por las aplicaciones cliente (las que generan peticiones de lectura o escritura en HDFS) son recibidas siempre por ambos namenodes. En la pr√°ctica, este proceso apenas lleva un minuto hasta que se restablece el servicio normal gracias al nuevo namenode.

* **Escalando el namenode: namenodes federados**

Este mecanismo se utiliza cuando el namenode se encuentra saturado y cerca de llenarse. No es un mecanismo de protecci√≥n contra fallos como tal, aunque tambi√©n cumple esa funci√≥n. Consiste en que varios namenodes que funcionan a la vez se encargan de directorios distintos del sistema de archivos, sin solapamiento. Por ejemplo: los metadatos relativos a todo el √°rbol de directorios que cuelga de /user se pueden almacenar en un namenode, mientras que todo el √°rbol que cuelga de /share lo puede hacer en otro. De esta manera, el posible fallo de un namenode no afecta en nada a los archivos o directorios que no cuelgan de esa jerarqu√≠a. Los datanodes s√≠ pueden almacenar indistintamente bloques de archivos de varios namespaces (es decir, de varios sub√°rboles).

### ‚úèÔ∏èProceso de Lectura y Escritura de HDFS

#### **Proceso de Lectura**

1. El cliente solicita un archivo al NameNode mediante una llamada RPC.
2. El NameNode consulta los metadatos y devuelve la lista de bloques con su ubicaci√≥n.
3. El cliente contacta con los DataNodes para obtener los bloques.
4. El cliente lee los datos como un flujo continuo a trav√©s de FSDataInputStream.
5. Si es necesario, vuelve a consultar al NameNode por nuevas ubicaciones.
6. Finalmente, el cliente reconstruye el archivo.

#### **Proceso de Escritura**

1. El cliente solicita al NameNode escribir un archivo mediante RPC.
2. El NameNode verifica permisos y si el archivo puede ser creado.
3. El cliente usa FSDataOutputStream para dividir el archivo en bloques y encolarlos.
4. El NameNode asigna DataNodes para almacenar cada bloque.
5. El cliente env√≠a los bloques al primer DataNode, que los replica en cadena.
6. El √∫ltimo DataNode confirma la escritura al cliente a trav√©s de acks.
7. Cuando todos los bloques est√°n escritos, el cliente notifica al NameNode.

---

## üíª Comandos de HDFS m√°s frecuentes

### 1. Exploraci√≥n de archivos
- `hdfs dfs -ls /ruta` ‚Üí Lista los archivos de un directorio.  
- `hdfs dfs -ls -R /ruta` ‚Üí Lista archivos de forma recursiva.  
- `hdfs dfs -du -h /ruta` ‚Üí Muestra el uso de espacio en HDFS.  
- `hdfs dfs -df -h` ‚Üí Muestra el espacio libre en HDFS.  

### 2. Gesti√≥n de archivos
- `hdfs dfs -mkdir /ruta` ‚Üí Crea un directorio en HDFS.  
- `hdfs dfs -rm /ruta/archivo` ‚Üí Elimina un archivo.  
- `hdfs dfs -rm -r /ruta` ‚Üí Elimina un directorio recursivamente.  
- `hdfs dfs -mv /origen /destino` ‚Üí Mueve o renombra archivos.  
- `hdfs dfs -copyFromLocal archivo /ruta` ‚Üí Copia un archivo local a HDFS.  
- `hdfs dfs -copyToLocal /ruta/archivo ./` ‚Üí Copia un archivo de HDFS a local.  

### 3. Lectura y escritura de archivos
- `hdfs dfs -cat /ruta/archivo` ‚Üí Muestra el contenido de un archivo.  
- `hdfs dfs -tail /ruta/archivo` ‚Üí Muestra las √∫ltimas l√≠neas de un archivo.  
- `hdfs dfs -text /ruta/archivo` ‚Üí Muestra el contenido de archivos comprimidos en texto.  

### 4. Permisos y propietarios
- `hdfs dfs -chmod 755 /ruta` ‚Üí Cambia permisos de un archivo o carpeta.  
- `hdfs dfs -chown usuario:grupo /ruta` ‚Üí Cambia el propietario de un archivo.  

### 5. Informaci√≥n del sistema
- `hdfs dfsadmin -report` ‚Üí Muestra el estado del cl√∫ster HDFS.  
- `hdfs dfsadmin -safemode get` ‚Üí Verifica si el NameNode est√° en modo seguro.  

Estos comandos permiten gestionar y explorar HDFS de manera eficiente. üöÄ

---

## üíª Programaci√≥n distribuida y MapReduce

### Concepto

MapReduce es un modelo de programaci√≥n distribuida para procesar grandes vol√∫menes de datos en paralelo en un cl√∫ster. Fue desarrollado por Google para aprovechar los datanodes de un sistema distribuido (como HDFS), evitando mover los datos y llevando el procesamiento a donde est√°n almacenados.

### Funcionamiento

- **Mapper**: Procesa los bloques de datos de entrada en paralelo, generando pares *(clave, valor).*
- **Shuffle and Sort**: Agrupa las claves iguales y organiza los valores asociados.
- **Reducer**: Procesa las agrupaciones generadas por el shuffle, combinando los valores en un resultado final.

### Ejemplo: Contar palabras en un texto

1. **Mapper**: Procesa cada l√≠nea de texto y emite *(palabra, 1)* por cada palabra encontrada.
2. **Shuffle and Sort**: Agrupa los pares con la misma palabra.
3. **Reducer**: Suma los valores asociados a cada palabra, generando *(palabra, total_apariciones).*

### Ventajas

- Procesamiento distribuido y paralelo.
- Abstrae al programador de detalles t√©cnicos de hardware y comunicaci√≥n.
- Escalabilidad en grandes vol√∫menes de datos.

### Inconvenientes

- **Escritura en disco**: Cada fase escribe en disco, lo que reduce el rendimiento.
- **Tr√°fico de red**: Necesario para el shuffle, afectando la eficiencia.
- **Dificultad de implementaci√≥n**: No siempre es intuitivo modelar problemas en MapReduce.
- **Ineficiente en algoritmos iterativos**: Como en machine learning, debido a las continuas lecturas y escrituras en disco.

### Conclusi√≥n

MapReduce es un paradigma poderoso para el procesamiento distribuido, pero presenta limitaciones que han llevado al desarrollo de enfoques m√°s eficientes como Apache Spark.

### Bibliograf√≠a

1. [Hadoop](https://www.databricks.com/glossary/hadoop)
2. [Como usar HDFS](https://colab.research.google.com/drive/14VR3FVF1zZK2SkDnEgndJt1ClLnEBh6P?usp=sharing)
3. [Como programar en MapReduce](https://colab.research.google.com/drive/13Bz_zpgYaIFmo404drHw7VUDP2uUSNRq?usp=sharing)