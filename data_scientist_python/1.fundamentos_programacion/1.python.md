# Curso de Python

## 1. Fundamentos de Programación de Python

### 1.1. ¿Porque Python?

* Fue creado por Guido Van Rossum en 1991.
* Lenguaje de alto nivel.
* Lenguaje interpretado(Ejecuta línea por línea sin ser compilado).
* Tipado dinamico (No es necesario especificar el tipo de dato).
* Tiene diferentes paradigmas como Programación orientada a objetos y funcional.

### 1.2. Introducción a Python

Para realizar el primer hola mundo se instala lo siguiente:

* Python -> [Enlace](https://www.python.org/doc/)
* Visual Studio Code -> [Enlace](https://code.visualstudio.com/)

### 1.3. Conceptos Básicos de Programación

* **Sintaxis:** Son las reglas que determinan como escribir correctamente el codigo (Estructura).
* **Semantica:** Es el comportamiento del codigo (Lo que hace)

### 1.4. Manipulación de Cadenas de Texto en Python

```Python
print(nombre.upper()) # Convierte en mayuscula el string
print(nombre.lower()) # Convierte en minuscula el string
print(segundo_apellido.strip()) # Quita espacios al inicio y al final
print(nombre_completo.split()) # Convierte en una lista el string con un separador
print(nombre_completo.replace("Gian", "Dark")) # Reemplaza un texto por otro
print(nombre.startswith("G")) # Evalua si comienza con un texto
print(nombre.endswith("O")) # Evalua si termina con un texto
print(nombre_completo.find("Hol")) # Busca un texto
print(len(nombre_completo)) # Tamaño de la cadena
print(" ".join(lista)) # Une una lista de cadenas en una sola cadena usando un separador.
print(nombre_completo.count("a")) # Cuenta cuántas veces aparece una subcadena en la cadena original.
print(numeros.isnumeric()) # Comprueba si la cadena contiene solo caracteres numéricos.
print(numeros.isdigit()) # Comprueba si la cadena contiene solo caracteres numéricos.
```

### 1.5. Enteros, Flotantes y Booleanos

```python
x = 123 # Int
y = 1.2E2 # Float
z = 1.2E-3 # Float
is_true = True # Bool
is_false = False # Bool
```

### 1.6. Print

Puedes imprimir de la siguiente manera

```python
print("Hola Mundo")
mundo = "Mundo"
print(f"Hola {mundo}")
print("Hola {}".format(mundo))
```

### 1.7. Operaciones Matemáticas y Operaciones de Entrada y Salida

```python
# Elaboración de una calculadora

print("="*30)
print(" "*9,"CALCULADORA")
print("="*30)

x1 = int(input("Ingresa el número 1: "))
x2 = int(input("Ingresa el número 2: "))
op = input('''Que operación te gustaría realizar?
1. Suma
2. Resta
3. Multiplicación
4. División
5. División entera
6. Residuo o modulo
7. Potenciación
''')

def calculadora(x1,x2,op):
    if op == "1":
        return x1 + x2
    elif op == "2":
        return x1 - x2
    elif op == "3":
        return x1 * x2
    elif op == "4":
        return x1 / x2
    elif op == "5":
        return x1 // x2
    elif op == "6":
        return x1 % x2
    elif op == "7":
        return x1 ** x2
    else:
        return "Operación no válida"
    
print(f"El resultado de la operación es: {calculadora(x1,x2,op)}")
```

## 2. Colección y procesamiento de datos

### 2.1. Listas

```python
# Lista de ejemplo
numeros = [1, 3, 5, 7]
letras = ['a', 'b', 'c']

# 1. append(item) - Agrega un elemento al final de la lista
numeros.append(9)
print(numeros)  # [1, 3, 5, 7, 9]

# 2. extend(iterable) - Extiende la lista con otra lista o iterable
numeros.extend([11, 13])
print(numeros)  # [1, 3, 5, 7, 9, 11, 13]

# 3. insert(index, item) - Inserta un elemento en una posición específica
numeros.insert(1, 2)
print(numeros)  # [1, 2, 3, 5, 7, 9, 11, 13]

# 4. remove(item) - Elimina el primer elemento que coincida con el valor dado
numeros.remove(5)
print(numeros)  # [1, 2, 3, 7, 9, 11, 13]

# 5. pop(index) - Elimina y devuelve el elemento en el índice dado (o el último si no se especifica)
ultimo_elemento = numeros.pop()
print(ultimo_elemento)  # 13
print(numeros)  # [1, 2, 3, 7, 9, 11]

# 6. sort() - Ordena la lista en su lugar
numeros.sort()
print(numeros)  # [1, 2, 3, 7, 9, 11]

# 7. sorted(list) - Devuelve una lista nueva ordenada (sin modificar la original)
letras_ordenadas = sorted(letras, reverse=True)
print(letras_ordenadas)  # ['c', 'b', 'a']
print(letras)  # ['a', 'b', 'c'] (la lista original no cambia)

# 8. reverse() - Invierte el orden de los elementos de la lista
letras.reverse()
print(letras)  # ['c', 'b', 'a']

# 9. len(list) - Devuelve la cantidad de elementos en la lista
print(len(numeros))  # 6

# 10. index(item) - Devuelve el índice de la primera aparición del elemento
print(numeros.index(7))  # 3

# 11. count(item) - Cuenta cuántas veces aparece un elemento en la lista
print(numeros.count(3))  # 1

# 12. sum(list) - Devuelve la suma de los elementos numéricos de la lista
print(sum(numeros))  # 33

# 13. min(list) / max(list) - Devuelve el valor mínimo y máximo de la lista
print(min(numeros))  # 1
print(max(numeros))  # 11

# 14. List comprehension - Aplica una operación a cada elemento de la lista y crea una nueva lista
numeros_doblados = [x * 2 for x in numeros]
print(numeros_doblados)  # [2, 4, 6, 14, 18, 22]
```

### 2.2. Slice

```python
# Lista de ejemplo
numeros = [10, 20, 30, 40, 50, 60, 70, 80, 90]

# 1. Acceder a un segmento de la lista usando slicing
# Sintaxis: lista[inicio:fin]
print(numeros[2:5])  # [30, 40, 50] (desde índice 2 hasta el 4, no incluye el 5)

# 2. Omitir el índice de inicio - toma desde el principio
print(numeros[:4])  # [10, 20, 30, 40] (desde el inicio hasta el índice 3)

# 3. Omitir el índice de fin - toma hasta el final
print(numeros[5:])  # [60, 70, 80, 90] (desde el índice 5 hasta el final)

# 4. Usar índices negativos - cuenta desde el final de la lista
print(numeros[-4:])  # [60, 70, 80, 90] (los últimos 4 elementos)

# 5. Extraer cada segundo elemento usando step
# Sintaxis: lista[inicio:fin:paso]
print(numeros[::2])  # [10, 30, 50, 70, 90] (cada 2 elementos)

# 6. Revertir la lista usando un step negativo
print(numeros[::-1])  # [90, 80, 70, 60, 50, 40, 30, 20, 10] (lista al revés)

# 7. Slice para asignar nuevos valores a una parte de la lista
numeros[2:5] = [300, 400, 500]
print(numeros)  # [10, 20, 300, 400, 500, 60, 70, 80, 90]

# 8. Eliminar una sección de la lista con slicing
numeros[2:5] = []
print(numeros)  # [10, 20, 60, 70, 80, 90]

# 9. Usar slice con strings (funciona igual que con listas)
cadena = "Ciencia de Datos"
print(cadena[0:7])  # 'Cienci' (primeras 7 letras)
print(cadena[::-1])  # 'sotaD ed aicneic' (string al revés)
```

### 2.4. Tuplas

Las tuplas en Python son similares a las listas, pero inmutables, lo que significa que no se pueden modificar después de su creación (no puedes añadir, eliminar o cambiar elementos). Sin embargo, puedes utilizar slicing en tuplas para extraer partes de ellas.

```python
# Tupla de ejemplo
tupla_numeros = (1, 3, 5, 7)
tupla_letras = ('a', 'b', 'c')

# 1. len(tuple) - Devuelve la cantidad de elementos en la tupla
print(len(tupla_numeros))  # 4

# 2. index(item) - Devuelve el índice de la primera aparición del elemento
print(tupla_numeros.index(5))  # 2

# 3. count(item) - Cuenta cuántas veces aparece un elemento en la tupla
print(tupla_numeros.count(7))  # 1

# 4. min(tuple) - Devuelve el valor mínimo de la tupla
print(min(tupla_numeros))  # 1

# 5. max(tuple) - Devuelve el valor máximo de la tupla
print(max(tupla_numeros))  # 7

# 6. sum(tuple) - Devuelve la suma de los elementos de la tupla (si son numéricos)
print(sum(tupla_numeros))  # 16

# 7. sorted(tuple) - Devuelve una lista con los elementos ordenados de la tupla (no modifica la tupla)
tupla_ordenada = sorted(tupla_numeros)
print(tupla_ordenada)  # [1, 3, 5, 7]

# 8. tuple() - Convierte una lista o iterable en una tupla
lista_a_convertir = [10, 20, 30]
tupla_convertida = tuple(lista_a_convertir)
print(tupla_convertida)  # (10, 20, 30)

# 9. Concatenación de tuplas - Crea una nueva tupla a partir de otras
nueva_tupla = tupla_numeros + tupla_convertida
print(nueva_tupla)  # (1, 3, 5, 7, 10, 20, 30)

# 10. Repetición de tuplas - Repite los elementos de la tupla
tupla_repetida = tupla_letras * 2
print(tupla_repetida)  # ('a', 'b', 'c', 'a', 'b', 'c')

# 11. Slicing (rebanado) - Acceder a una porción de la tupla
sub_tupla = tupla_numeros[1:3]
print(sub_tupla)  # (3, 5)

# 12. Desempaquetado de tupla - Asignar los valores de la tupla a variables individuales
a, b, c, d = tupla_numeros
print(a, b, c, d)  # 1 3 5 7

# 13. List comprehension con tuplas - Crear una lista aplicando operaciones a una tupla
lista_doblada = [x * 2 for x in tupla_numeros]
print(lista_doblada)  # [2, 6, 10, 14]

# 14. Chequear si un elemento está en la tupla
print(3 in tupla_numeros)  # True
print(8 in tupla_numeros)  # False
```

### 2.5. Diccionarios

Los diccionarios almacenan datos en pares de clave-valor y permiten acceder, modificar y manejar la información de forma eficiente.

```python
# Diccionario de ejemplo
diccionario = {'nombre': 'Juan', 'edad': 25, 'ciudad': 'Madrid'}

# 1. Accesso a valor por clave
print(diccionario['nombre'])  # Juan

# 2. get(clave, valor_por_defecto) - Obtiene el valor de una clave, devuelve un valor por defecto si no existe
print(diccionario.get('edad'))  # 25
print(diccionario.get('altura', 'Desconocido'))  # Desconocido

# 3. add / update (Agregar o actualizar un valor en el diccionario)
diccionario['profesión'] = 'Ingeniero'  # Agrega una nueva clave-valor
print(diccionario)  # {'nombre': 'Juan', 'edad': 25, 'ciudad': 'Madrid', 'profesión': 'Ingeniero'}

diccionario['edad'] = 26  # Actualiza el valor de una clave existente
print(diccionario)  # {'nombre': 'Juan', 'edad': 26, 'ciudad': 'Madrid', 'profesión': 'Ingeniero'}

# 4. keys() - Devuelve todas las claves del diccionario
print(diccionario.keys())  # dict_keys(['nombre', 'edad', 'ciudad', 'profesión'])

# 5. values() - Devuelve todos los valores del diccionario
print(diccionario.values())  # dict_values(['Juan', 26, 'Madrid', 'Ingeniero'])

# 6. items() - Devuelve pares clave-valor como tuplas
print(diccionario.items())  # dict_items([('nombre', 'Juan'), ('edad', 26), ('ciudad', 'Madrid'), ('profesión', 'Ingeniero')])

# 7. pop(clave) - Elimina una clave y devuelve su valor
profesion = diccionario.pop('profesión')
print(profesion)  # Ingeniero
print(diccionario)  # {'nombre': 'Juan', 'edad': 26, 'ciudad': 'Madrid'}

# 8. popitem() - Elimina y devuelve el último par clave-valor añadido
ultimo_elemento = diccionario.popitem()
print(ultimo_elemento)  # ('ciudad', 'Madrid')
print(diccionario)  # {'nombre': 'Juan', 'edad': 26}

# 9. update(diccionario) - Actualiza un diccionario con otro
actualizacion = {'edad': 30, 'ciudad': 'Barcelona'}
diccionario.update(actualizacion)
print(diccionario)  # {'nombre': 'Juan', 'edad': 30, 'ciudad': 'Barcelona'}

# 10. del diccionario[clave] - Elimina un par clave-valor
del diccionario['ciudad']
print(diccionario)  # {'nombre': 'Juan', 'edad': 30}

# 11. fromkeys(iterable, valor) - Crea un diccionario con claves de un iterable y un valor por defecto
nuevas_claves = ['altura', 'peso']
diccionario_nuevo = dict.fromkeys(nuevas_claves, 'Desconocido')
print(diccionario_nuevo)  # {'altura': 'Desconocido', 'peso': 'Desconocido'}

# 12. clear() - Elimina todos los elementos del diccionario
diccionario.clear()
print(diccionario)  # {}

# 13. dict comprehension - Crear un diccionario aplicando operaciones a un iterable
numeros = [1, 2, 3]
cuadrados = {x: x**2 for x in numeros}
print(cuadrados)  # {1: 1, 2: 4, 3: 9}

# 14. Chequear si una clave está en el diccionario
print('edad' in diccionario)  # False
print('altura' in diccionario_nuevo)  # True
```

## 3. Control de Flujo en Python

### 3.1. Estructuras condicionales

```python
# 1. if (Condicional simple)
x = 10
if x > 5:
    print("x es mayor que 5")  # Se ejecuta si la condición es verdadera

# 2. if-else (Condicional con alternativa)
x = 3
if x > 5:
    print("x es mayor que 5")
else:
    print("x es menor o igual a 5")  # Se ejecuta si la condición es falsa

# 3. if-elif-else (Múltiples condiciones)
x = 7
if x > 10:
    print("x es mayor que 10")
elif x > 5:
    print("x es mayor que 5 pero menor o igual a 10")  # Se ejecuta si esta condición es verdadera
else:
    print("x es menor o igual a 5")  # Se ejecuta si ninguna de las anteriores es verdadera

# 4. Condicionales con operadores lógicos (and, or, not)
x = 8
y = 12
if x > 5 and y > 10:
    print("Ambas condiciones son verdaderas")  # Ambas condiciones deben ser verdaderas
if x > 10 or y > 10:
    print("Al menos una de las condiciones es verdadera")  # Solo una condición debe ser verdadera
if not x < 5:
    print("x no es menor que 5")  # Verifica si la condición es falsa

# 5. Condicional en una sola línea (if ternario)
edad = 18
mensaje = "Es mayor de edad" if edad >= 18 else "Es menor de edad"
print(mensaje)  # Imprime "Es mayor de edad" porque la condición es verdadera

# 6. Condicionales anidados (if dentro de if)
x = 20
if x > 10:
    print("x es mayor que 10")
    if x > 15:
        print("x también es mayor que 15")  # Se ejecuta solo si x > 10
    else:
        print("x es menor o igual a 15")

# 7. Uso de in para verificar pertenencia
fruta = "manzana"
if fruta in ["manzana", "naranja", "plátano"]:
    print("La fruta está en la lista")  # Verifica si el valor está en la lista

# 8. Comparaciones múltiples
x = 7
if 5 < x < 10:  # Verifica si x está entre 5 y 10
    print("x está entre 5 y 10")

# 9. pass en condicionales (cuando no necesitas acción)
x = 5
if x > 10:
    pass  # No hace nada
else:
    print("x es menor o igual a 10")

# 10. Uso de match para patrones en Python 3.10+ (similar a switch)
color = "rojo"
match color:
    case "rojo":
        print("El color es rojo")
    case "azul":
        print("El color es azul")
    case _:
        print("Otro color")  # Caso por defecto
```

### 3.2. Blucles e Interacciones

```python
# 1. Bucle for básico (recorriendo una lista)
numeros = [1, 2, 3, 4, 5]
for numero in numeros:
    print(numero)  # Imprime cada número de la lista

# 2. Bucle for con range() (rango de números)
for i in range(5):  # Rango de 0 a 4
    print(i)  # Imprime 0, 1, 2, 3, 4

# 3. Bucle for con range(inicio, fin, paso)
for i in range(0, 10, 2):  # Rango de 0 a 9, incrementando de 2 en 2
    print(i)  # Imprime 0, 2, 4, 6, 8

# 4. Bucle for anidado (bucles dentro de bucles)
for i in range(3):  # Bucle externo
    for j in range(2):  # Bucle interno
        print(f"Bucle externo {i}, Bucle interno {j}")

# 5. Iterar sobre un diccionario
diccionario = {'nombre': 'Juan', 'edad': 30, 'ciudad': 'Madrid'}
for clave, valor in diccionario.items():
    print(f"{clave}: {valor}")  # Imprime clave y valor

# 6. Bucle while (bucle que depende de una condición)
x = 5
while x > 0:
    print(x)
    x -= 1  # Decrementa x hasta que sea 0

# 7. Bucle while con condición infinita y break
x = 10
while True:  # Bucle infinito
    print(x)
    x -= 1
    if x == 5:  # Condición de salida
        break  # Rompe el bucle

# 8. Uso de continue en un bucle (salta a la siguiente iteración)
for i in range(5):
    if i == 2:
        continue  # Salta la iteración donde i es 2
    print(i)  # Imprime 0, 1, 3, 4 (no imprime 2)

# 9. Bucle con else (se ejecuta cuando el bucle termina sin interrupción)
for i in range(3):
    print(i)
else:
    print("Bucle completado sin interrupción")  # Se ejecuta si no hay break

# 10. List comprehension (bucle for en una sola línea para crear listas)
cuadrados = [x**2 for x in range(5)]
print(cuadrados)  # [0, 1, 4, 9, 16]

# 11. Iterar sobre una cadena de texto
texto = "Python"
for letra in texto:
    print(letra)  # Imprime cada letra de la cadena

# 12. Bucle for con enumerate() (obtener índice y valor)
frutas = ['manzana', 'naranja', 'plátano']
for indice, fruta in enumerate(frutas):
    print(f"{indice}: {fruta}")  # Imprime índice y valor

# 13. zip() para iterar sobre varias listas al mismo tiempo
nombres = ['Juan', 'Ana', 'Luis']
edades = [25, 30, 35]
for nombre, edad in zip(nombres, edades):
    print(f"{nombre} tiene {edad} años")  # Empareja nombres y edades

# 14. Bucle for con break y continue juntos
for i in range(5):
    if i == 2:
        continue  # Salta la iteración donde i es 2
    if i == 4:
        break  # Rompe el bucle cuando i es 4
    print(i)  # Imprime 0, 1, 3

# 15. Bucle while con else
x = 3
while x > 0:
    print(x)
    x -= 1
else:
    print("Terminó el bucle while")  # Se ejecuta al finalizar el bucle sin interrupción
```

### 3.3. Iterador y Generador

* **Iteradores:** Son objetos que permiten recorrer una colección de elementos (como listas o diccionarios) uno a uno, sin necesidad de conocer la estructura interna de la colección. Un objeto iterable implementa el método __iter__() que devuelve un iterador.

* **Generadores:** Son una forma especial de iteradores que permiten crear iteraciones de manera más simple y eficiente, usando la palabra clave yield. En lugar de retornar un valor y finalizar la función, yield permite que la función se pause y continúe desde ese punto cuando se llame de nuevo.

```python
# Generador de ejemplo
def generador_numeros():
    for i in range(5):
        yield i

# 1. Crear el generador
numeros = generador_numeros()

# 2. Usar el generador en un bucle
for numero in numeros:
    print(numero)  # Imprime números del 0 al 4

# 3. Usar la función next() para obtener el siguiente valor
numeros = generador_numeros()  # Reiniciar el generador
# Tambien se puede crear el iterador de la siguiente manera
numeros = iter(range(5))
print(next(numeros))  # 0
print(next(numeros))  # 1

# 4. Intentar obtener más números de los que existen
try:
    while True:
        print(next(numeros))  # Esto lanzará StopIteration cuando no haya más elementos
except StopIteration:
    print("Se han consumido todos los elementos.")
```

## 4. Funciones y Manejo de Excepsiones

### 4.1. Funciones

```python
# --- 1. Crear una función simple sin parámetros ---
def saludo():
    """Esta función imprime un saludo."""
    print("¡Hola, bienvenido a Python!")

# Llamar a la función
saludo()


# --- 2. Crear una función con parámetros ---
def saludo_personalizado(nombre):
    """Esta función saluda a una persona por su nombre."""
    print(f"¡Hola, {nombre}! ¿Cómo estás?")

# Llamar a la función con un argumento
saludo_personalizado("Carlos")


# --- 3. Función con parámetros por defecto ---
def saludo_por_defecto(nombre="invitado"):
    """Esta función saluda usando un nombre por defecto si no se proporciona."""
    print(f"¡Hola, {nombre}! Bienvenido.")

# Llamar a la función sin argumento
saludo_por_defecto()

# Llamar a la función con argumento
saludo_por_defecto("María")


# --- 4. Función que retorna un valor ---
def suma(a, b):
    """Esta función retorna la suma de dos números."""
    return a + b

# Llamar a la función y almacenar el resultado
resultado = suma(5, 7)
print(f"La suma es: {resultado}")


# --- 5. Función con múltiples valores de retorno ---
def operaciones_matematicas(a, b):
    """Esta función retorna la suma, resta, multiplicación y división de dos números."""
    suma = a + b
    resta = a - b
    multiplicacion = a * b
    division = a / b if b != 0 else "Indefinido"
    return suma, resta, multiplicacion, division

# Llamar a la función y desempaquetar los resultados
suma_res, resta_res, multiplicacion_res, division_res = operaciones_matematicas(10, 2)
print(f"Suma: {suma_res}, Resta: {resta_res}, Multiplicación: {multiplicacion_res}, División: {division_res}")


# --- 6. Funciones con argumentos arbitrarios (args) ---
def suma_numeros(*args):
    """Esta función suma una cantidad arbitraria de números."""
    return sum(args)

# Llamar a la función con diferentes números de argumentos
print(suma_numeros(1, 2, 3))  # Resultado: 6
print(suma_numeros(4, 5, 6, 7, 8))  # Resultado: 30


# --- 7. Funciones con argumentos arbitrarios nombrados (kwargs) ---
def detalles_persona(**kwargs):
    """Esta función acepta información personal como argumentos nombrados."""
    for clave, valor in kwargs.items():
        print(f"{clave}: {valor}")

# Llamar a la función con argumentos nombrados
detalles_persona(nombre="Ana", edad=30, ciudad="Lima")


# --- 8. Funciones lambda (funciones anónimas) ---
# Sumar dos números con una función lambda
suma_lambda = lambda a, b: a + b
print(suma_lambda(3, 4))  # Resultado: 7

# Lambda dentro de otra función
def operacion_con_lambda(a, b, funcion):
    """Esta función recibe dos números y una función para aplicarla a esos números."""
    return funcion(a, b)

# Llamar a la función pasando una lambda como argumento
resultado = operacion_con_lambda(10, 5, lambda x, y: x * y)
print(f"Multiplicación con lambda: {resultado}")


# --- 9. Funciones recursivas ---
def factorial(n):
    """Esta función calcula el factorial de un número usando recursión."""
    if n == 1:
        return 1
    else:
        return n * factorial(n - 1)

# Llamar a la función factorial
print(f"Factorial de 5: {factorial(5)}")  # Resultado: 120


# --- 10. Funciones anidadas ---
def exterior(texto):
    """Función que contiene otra función dentro."""
    def interior():
        print(f"Texto dentro de la función interior: {texto}")
    
    interior()

# Llamar a la función que contiene una función anidada
exterior("¡Hola desde la función interior!")
```

### 4.2. Programación Funcional

La programación funcional es un paradigma de programación que trata a las funciones como "ciudadanos de primera clase".
Esto significa que las funciones pueden ser pasadas como argumentos, retornadas por otras funciones y almacenadas en variables.
En este estilo de programación, se evita cambiar el estado o mutar datos, promoviendo el uso de funciones puras.
Las funciones puras son aquellas cuyo resultado depende solo de los argumentos de entrada, sin causar efectos secundarios.

```python
# --- 1. Funciones de orden superior ---
# Una función de orden superior toma otra función como argumento o retorna una función.

def aplicar_operacion(a, b, operacion):
    """Esta función aplica una operación a dos números."""
    return operacion(a, b)

# Ejemplo usando una función lambda
resultado = aplicar_operacion(10, 5, lambda x, y: x + y)
print(f"Suma con función de orden superior: {resultado}")  # Resultado: 15


# --- 2. Función map() ---
# map() aplica una función a cada elemento de un iterable y devuelve un nuevo iterable.

numeros = [1, 2, 3, 4, 5]

# Elevar cada número al cuadrado
cuadrados = list(map(lambda x: x**2, numeros))
print(f"Cuadrados: {cuadrados}")  # Resultado: [1, 4, 9, 16, 25]


# --- 3. Función filter() ---
# filter() filtra los elementos de un iterable según una función condicional.

# Filtrar números mayores que 2
mayores_que_dos = list(filter(lambda x: x > 2, numeros))
print(f"Mayores que 2: {mayores_que_dos}")  # Resultado: [3, 4, 5]


# --- 4. Función reduce() ---
# reduce() aplica una función acumulativa a los elementos de un iterable para reducirlos a un solo valor.
from functools import reduce

# Sumar todos los números de la lista
suma_total = reduce(lambda x, y: x + y, numeros)
print(f"Suma total: {suma_total}")  # Resultado: 15


# --- 5. Funciones lambda ---
# Las funciones lambda son funciones anónimas de una sola línea.

# Sumar dos números con lambda
suma_lambda = lambda a, b: a + b
print(f"Suma con lambda: {suma_lambda(3, 4)}")  # Resultado: 7

# Usar lambda para ordenar una lista de tuplas por el segundo valor
tuplas = [(1, 'b'), (2, 'a'), (3, 'c')]
tuplas_ordenadas = sorted(tuplas, key=lambda x: x[1])
print(f"Tuplas ordenadas: {tuplas_ordenadas}")  # Resultado: [(2, 'a'), (1, 'b'), (3, 'c')]


# --- 6. Funciones como objetos de primera clase ---
# En Python, las funciones son objetos de primera clase, lo que significa que pueden ser almacenadas en variables, pasadas como argumentos y retornadas.

def multiplicar_por_dos(x):
    """Esta función multiplica un número por 2."""
    return x * 2

# Almacenar la función en una variable
mi_funcion = multiplicar_por_dos

# Llamar a la función almacenada en la variable
print(mi_funcion(5))  # Resultado: 10


# --- 7. Funciones anidadas y clausuras ---
# Las funciones anidadas pueden recordar los valores de las variables locales del contexto donde fueron creadas, esto se llama una clausura.

def crear_multiplicador(n):
    """Esta función genera una función que multiplica por 'n'."""
    def multiplicar(x):
        return x * n
    return multiplicar

# Crear una función que multiplica por 3
multiplicador_por_3 = crear_multiplicador(3)

# Usar la función generada
print(multiplicador_por_3(10))  # Resultado: 30


# --- 8. Función zip() ---
# zip() combina elementos de varios iterables en tuplas.

numeros = [1, 2, 3]
letras = ['a', 'b', 'c']

# Combinar listas en una lista de tuplas
combinacion = list(zip(numeros, letras))
print(f"Combinación: {combinacion}")  # Resultado: [(1, 'a'), (2, 'b'), (3, 'c')]


# --- 9. Listas por comprensión ---
# Las listas por comprensión permiten aplicar una operación a cada elemento de un iterable de manera concisa.

# Crear una lista con los cuadrados de los números del 1 al 5
cuadrados = [x**2 for x in range(1, 6)]
print(f"Cuadrados con comprensión de listas: {cuadrados}")  # Resultado: [1, 4, 9, 16, 25]

# Filtrar números pares usando comprensión de listas
pares = [x for x in range(10) if x % 2 == 0]
print(f"Pares: {pares}")  # Resultado: [0, 2, 4, 6, 8]


# --- 10. Funciones recursivas ---
# La recursión es una técnica donde una función se llama a sí misma para resolver un problema.

def fibonacci(n):
    """Función recursiva para calcular el enésimo número de Fibonacci."""
    if n <= 1:
        return n
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

# Calcular el quinto número de Fibonacci
print(f"Fibonacci de 5: {fibonacci(5)}")  # Resultado: 5
```

### 4.3. Manejo de Errores

```python
# Para ver todas las excepsiones
def print_exception_hierarchy(exception_class, indent=0):
    print(' ' * indent + exception_class.__name__)
    for subclass in exception_class.__subclasses__():
        print_exception_hierarchy(subclass, indent + 4)

print_exception_hierarchy(Exception)

# Ejmplo de manejo de excepsiones
while True:
    try:
        divisor = int(input("Ingresa un numero divisor: "))
        result = 100/divisor
        print(result)
    except ZeroDivisionError as e:
        print("ERROR: No se puede dividir entre 0")
        print("Ha ocurrido un error del tipo:", e)
    except ValueError as e:
        print("ERROR: Debes introducir cualquier numero que no sea cero")
        print("Ha ocurrido un error del tipo:", e)
```

## 5. Programación Orientada a Objetos

### 5.1. Programación Orientada a Objetos

La programación orientada a objetos (POO) es un paradigma de programación que se basa en el concepto de "objetos".
Un objeto es una instancia de una clase, que es una plantilla o molde que define las propiedades (atributos) y
comportamientos (métodos) que los objetos de esa clase pueden tener.
La POO permite estructurar el código en torno a estos objetos, facilitando la modularidad, reutilización y abstracción.

### 5.2. Conceptos Claves de POO

- Clase: Es el diseño o plantilla que define atributos y métodos.
- Objeto: Es una instancia de una clase.
- Atributo: Es una variable que pertenece a un objeto o clase, en la vida real sería su características.
- Método: Es una función que pertenece a un objeto o clase, en la vida real sería la acción que va realizar el objeto.
- Herencia: Permite que una clase derive de otra, heredando sus atributos y métodos.
- Encapsulamiento: Restringe el acceso directo a los atributos de un objeto.
- Polimorfismo: Permite usar una misma interfaz para distintos tipos de objetos.
-


```Python
# --- 1. Definición de una clase y creación de objetos ---
class Persona:
    """Clase que representa a una persona."""
    def __init__(self, nombre, edad):
        """Método constructor que inicializa los atributos nombre y edad."""
        self.nombre = nombre
        self.edad = edad
    
    def saludar(self):
        """Método para que la persona salude."""
        print(f"Hola, me llamo {self.nombre} y tengo {self.edad} años.")

# Crear una instancia de la clase Persona (un objeto)
persona1 = Persona("Carlos", 30)

# Llamar al método saludar del objeto
persona1.saludar()  # Resultado: "Hola, me llamo Carlos y tengo 30 años."


# --- 2. Atributos de clase y atributos de instancia ---
class Coche:
    """Clase que representa un coche."""
    # Atributo de clase (compartido por todas las instancias)
    ruedas = 4

    def __init__(self, marca, modelo):
        """Atributos de instancia (específicos para cada objeto)"""
        self.marca = marca
        self.modelo = modelo

# Crear dos objetos (instancias) de la clase Coche
coche1 = Coche("Toyota", "Corolla")
coche2 = Coche("Honda", "Civic")

# Acceder a atributos de clase y de instancia
print(f"{coche1.marca} {coche1.modelo} tiene {coche1.ruedas} ruedas.")  # "Toyota Corolla tiene 4 ruedas."
print(f"{coche2.marca} {coche2.modelo} tiene {coche2.ruedas} ruedas.")  # "Honda Civic tiene 4 ruedas."


# --- 3. Métodos de clase y métodos estáticos ---
class Ejemplo:
    # Atributo de clase
    contador = 0
    
    def __init__(self):
        # Incrementa el contador cada vez que se crea una instancia
        Ejemplo.contador += 1

    @staticmethod
    def metodo_estatico(a, b):
        """Método estático que no depende de la clase ni de la instancia."""
        return a + b
    
    @classmethod
    def metodo_de_clase(cls):
        """Método de clase que accede a los atributos o métodos de la clase."""
        return f"El número de instancias creadas es: {cls.contador}"

# Uso de un método estático
resultado_suma = Ejemplo.metodo_estatico(5, 3)
print(f"Resultado del método estático: {resultado_suma}")  # Resultado: 8

# Crear instancias de la clase Ejemplo
objeto1 = Ejemplo()
objeto2 = Ejemplo()

# Uso de un método de clase
resultado_clase = Ejemplo.metodo_de_clase()
print(resultado_clase)  # Resultado: El número de instancias creadas es: 2
```

### 5.3. Pilares de la POO

1. Encapsulamiento
2. Abstracción
3. Herencia
4. Polimorfismo

```python
# --- 1. Encapsulamiento ---
# El encapsulamiento es el mecanismo que restringe el acceso directo a ciertos atributos o métodos de un objeto,
# protegiendo los datos internos. Solo se puede interactuar con esos atributos mediante métodos públicos definidos en la clase.

class CuentaBancaria:
    """Clase que encapsula el saldo de una cuenta bancaria."""
    
    def __init__(self, saldo_inicial):
        # Atributo privado (no accesible desde fuera de la clase)
        self.__saldo = saldo_inicial

    def depositar(self, cantidad):
        """Método para depositar dinero."""
        if cantidad > 0:
            self.__saldo += cantidad

    def retirar(self, cantidad):
        """Método para retirar dinero."""
        if 0 < cantidad <= self.__saldo:
            self.__saldo -= cantidad

    def obtener_saldo(self):
        """Método para obtener el saldo actual."""
        return self.__saldo

# Crear una cuenta y depositar/retirar dinero
cuenta = CuentaBancaria(1000)
cuenta.depositar(500)
cuenta.retirar(200)
print(f"Saldo actual (encapsulado): {cuenta.obtener_saldo()}")  # Saldo actual: 1300

# Intentar acceder directamente al atributo privado causará un error
# print(cuenta.__saldo)  # Esto dará error

# --- 2. Abstracción ---
# La abstracción consiste en ocultar los detalles complejos de implementación y exponer solo la funcionalidad esencial.
# Esto se logra definiendo interfaces claras (métodos públicos) y manteniendo la lógica interna oculta al usuario de la clase.

class Coche:
    """Clase que representa un coche, con detalles internos ocultos mediante abstracción."""
    
    def __init__(self, marca, modelo):
        self.marca = marca
        self.modelo = modelo
        self.__estado_motor = "apagado"  # Atributo privado

    def encender(self):
        """Método público para encender el coche."""
        self.__estado_motor = "encendido"
        print(f"{self.marca} {self.modelo} está encendido.")

    def apagar(self):
        """Método público para apagar el coche."""
        self.__estado_motor = "apagado"
        print(f"{self.marca} {self.modelo} está apagado.")

# Crear un objeto Coche y usar su interfaz pública
coche = Coche("Toyota", "Corolla")
coche.encender()  # Salida: "Toyota Corolla está encendido."
coche.apagar()    # Salida: "Toyota Corolla está apagado."

# Los detalles sobre cómo se maneja el estado del motor están ocultos

# --- 3. Herencia ---
# La herencia permite que una clase (clase hija) herede los atributos y métodos de otra clase (clase padre), 
# lo que promueve la reutilización de código.

class Animal:
    """Clase base que representa un animal."""
    def __init__(self, nombre):
        self.nombre = nombre

    def hacer_sonido(self):
        """Método genérico que puede ser sobrescrito por clases hijas."""
        return "Algún sonido"

# Clase hija que hereda de Animal
class Perro(Animal):
    def hacer_sonido(self):
        """Método sobrescrito que devuelve el sonido del perro."""
        return "Guau"

# Clase hija que hereda de Animal
class Gato(Animal):
    def hacer_sonido(self):
        """Método sobrescrito que devuelve el sonido del gato."""
        return "Miau"

# Crear instancias de las clases hijas y usar los métodos heredados y sobrescritos
perro = Perro("Max")
gato = Gato("Luna")

print(f"El perro {perro.nombre} hace: {perro.hacer_sonido()}")  # Resultado: "El perro Max hace: Guau"
print(f"El gato {gato.nombre} hace: {gato.hacer_sonido()}")    # Resultado: "El gato Luna hace: Miau"

# --- 4. Polimorfismo ---
# El polimorfismo permite que una misma interfaz (como un método) sea usada por diferentes clases,
# lo que permite tratar a objetos de distintas clases de manera uniforme.

class Pato:
    def hacer_sonido(self):
        return "Cuac"

class Vaca:
    def hacer_sonido(self):
        return "Muuu"

# Función que acepta cualquier objeto que tenga el método hacer_sonido
def imprimir_sonido(animal):
    print(animal.hacer_sonido())

# Crear instancias de las clases Pato y Vaca
pato = Pato()
vaca = Vaca()

# Usar el mismo método (hacer_sonido) en diferentes tipos de objetos
imprimir_sonido(pato)  # Resultado: "Cuac"
imprimir_sonido(vaca)  # Resultado: "Muuu"

# --- Ejemplo adicional de polimorfismo con herencia ---
# La función imprimir_sonido también puede aceptar objetos de clases que heredan de Animal
imprimir_sonido(perro)  # Resultado: "Guau"
imprimir_sonido(gato)   # Resultado: "Miau"

```

## 6. Lectura y Escritura de Archivos

## 6.1. Manejo de Archivos .TXT

```python
# --- Lectura de archivos de texto ---

# Medir el tiempo de ejecución de una función
import timeit

def leer_archivo_txt(ruta):
    """Lee un archivo de texto y muestra su contenido."""
    try:
        with open(ruta, 'r') as archivo:
            contenido = archivo.read()
            print(contenido)
    except FileNotFoundError:
        print("ERROR: El archivo no existe.")
    except PermissionError:
        print("ERROR: No tienes permiso para leer el archivo.")

# Llamar a la función con un archivo de texto existente
# leer_archivo_txt('data/caperucita.txt')

def leer_archivos_grandes(ruta):
    try:
        with open(ruta, 'r') as archivo:
            for linea in archivo:
                yield linea
    except FileNotFoundError:
        print("ERROR: El archivo no existe.")
    except PermissionError:
        print("ERROR: No tienes permiso para leer el archivo.")

tiempo_texto = timeit.timeit('leer_archivo_txt("data/caperucita.txt")', globals=globals(), number=1)
print(f"Tiempo de ejecución: {tiempo_texto} segundos")

tiempo_optimizado = timeit.timeit('leer_archivos_grandes("data/caperucita.txt")', globals=globals(), number=1)
print(f"Tiempo de ejecución optimizado: {tiempo_optimizado} segundos")

# Llamar a la función optimizada
#for linea in leer_archivos_grandes('data/caperucita.txt'):
#    print(linea, end='')

# --- Escritura de archivos de texto ---

def escribir_archivo_txt(ruta, contenido):
    """Escribe un archivo de texto con el contenido especificado."""
    try:
        with open(ruta, 'w') as archivo:
            archivo.write(contenido)
        print("Archivo creado exitosamente.")
    except PermissionError:
        print("ERROR: No tienes permiso para escribir el archivo.")

# Llamar a la función para escribir un archivo
escribir_archivo_txt('data/nuevo.txt', '¡Hola, mundo!')
```

### 6.2. Manejo de archivos CSV

```python
# --- Lectura de archivos CSV ---

import csv

#Leer un archivo
"""with open('products.csv', mode='r') as file:
    csv_reader = csv.DictReader(file)
    for row in csv_reader:
        print(row)"""

#Mostrar la informaciÃ³n por columnas
with open('products.csv', mode='r') as file:
    csv_reader = csv.DictReader(file)
    for row in csv_reader:
        print(f"Producto: {row['name']}, Precio: {row['price']}")

# --- Escritura de archivos CSV ---
import csv

monthly_sales = {}

with open('monthly_sales.csv', mode='r') as file:
    reader = csv.DictReader(file)
    for row in reader:
        month = row['Month']
        sales = int(row['Sales'])
        monthly_sales[month] = sales

print(monthly_sales)

# --- Nueva columna ---

import csv

file_path = 'products.csv'
updated_file_path = 'products_updated.csv'

with open(file_path, mode='r') as file:
    csv_reader = csv.DictReader(file)
    #Obtener los nombres de las columnas existentes
    fieldnames = csv_reader.fieldnames + ['total_value']

    with open(updated_file_path, mode='w', newline='') as updated_file:
        csv_writer = csv.DictWriter(updated_file, fieldnames=fieldnames)
        csv_writer.writeheader() #Escribir los encabezados

        for row in csv_reader:
            row['total_value'] = float(row['price']) * int(row['quantity'])
            csv_writer.writerow(row)
```

### 6.3. Manejo de Archivos JSON

```python
import json

#Lectura del archivo
with open('products.json', mode='r') as file:
    products = json.load(file)

#Mostrar el contenido
for product in products:
    #print(product)
    print(f"Product: {product['name']}, Price: {product['price']}")

# ---
import json

file_path = 'products.json'

new_product = {
    "name": "Wireless Charger",
    "price": 75,
    "quantity": 100,
    "brand": "ChargeMaster",
    "category": "Accessories",
    "entry_date": "2024-07-01"
}

with open(file_path, mode='r') as file:
    products = json.load(file)

products.append(new_product)

with open(file_path, mode='w') as file:
    json.dump(products, file, indent=4)
```

## 7. Biblioteca Estandar de Python

### 7.1. Conceptos

#### ¿Qué es la Biblioteca Estándar de Python?

La Biblioteca Estándar de Python es como tener un conjunto de herramientas integradas directamente en el lenguaje que te ayudan a realizar una variedad de tareas sin tener que reinventar la rueda. Desde la manipulación de archivos, pasando por cálculos matemáticos complejos, hasta la creación de servidores web, la Biblioteca Estándar tiene módulos que simplifican casi cualquier tarea que te propongas.

#### ¿Qué es una Librería y qué es un Módulo?

Antes de sumergirnos en cómo puedes aprovechar la Biblioteca Estándar, aclaremos dos conceptos clave:

* **Librería:** En Python, una librería es un conjunto organizado de módulos que puedes usar para añadir funcionalidades a tu código sin tener que escribirlas tú mismo. Piensa en ello como una colección de herramientas especializadas listas para usar.
* **Módulo:** Un módulo es un archivo de Python que contiene código que puedes reutilizar en tus proyectos. Un módulo puede incluir funciones, clases, y variables que te ayudan a resolver problemas específicos de manera eficiente.
Estos conceptos son fundamentales porque la Biblioteca Estándar está compuesta por una amplia variedad de módulos, cada uno diseñado para hacer tu vida como programador más fácil.

####  Explorando Áreas Clave de la Biblioteca Estándar
Ahora, veamos algunas de las áreas más importantes que cubre la Biblioteca Estándar:

* Manejo de Archivos y Sistema: Módulos como os, shutil, y pathlib te permiten interactuar con el sistema de archivos, lo cual es esencial para casi cualquier proyecto.
Operaciones Matemáticas: Módulos como math y random te proporcionan funciones matemáticas avanzadas y generación de números aleatorios.
* Manejo de Fechas y Tiempos: datetime y time te permiten trabajar con fechas y horas, lo cual es crucial para la programación de eventos o el registro de actividades.
* Manipulación de Datos: Módulos como json y csv son ideales para leer y escribir datos estructurados, algo común en el manejo de APIs y almacenamiento de información.
* Redes y Comunicaciones: Si estás construyendo aplicaciones que necesitan comunicarse a través de una red, socket y http.server te proporcionan las herramientas necesarias para gestionar conexiones y servidores web.
Estos módulos no solo te ahorran tiempo, sino que también te ayudan a escribir código más limpio y mantenible.

#### ¿Qué es pip y Cuándo Deberíamos Considerar Instalar una Librería?

La Biblioteca Estándar es extremadamente poderosa, pero a veces necesitarás algo más específico o avanzado. Aquí es donde entra pip, una herramienta que te permite instalar librerías adicionales que no vienen incluidas en Python por defecto.

#### ¿Cuándo deberías considerar instalar una librería?

Cuando necesitas funcionalidades que no están cubiertas por la Biblioteca Estándar.
Cuando quieres utilizar herramientas más especializadas para resolver problemas complejos.
Cuando necesitas una versión más reciente o específica de un módulo.
Por ejemplo, si estás trabajando en análisis de datos, podrías necesitar pandas, una librería poderosa para la manipulación y análisis de datos que no está en la Biblioteca Estándar.