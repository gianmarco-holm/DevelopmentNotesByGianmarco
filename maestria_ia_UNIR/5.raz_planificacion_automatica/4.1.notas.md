# BUSQUEDA NO INFORMADA

[Ejerrcicios](https://colab.research.google.com/drive/1AkCjL4UD7Dqij_hYYD5kTeI5xGRAPqtN?usp=sharing)

## 1. ğŸ§  DescripciÃ³n general de un problema de bÃºsqueda

Los problemas de bÃºsqueda se pueden catalogar de distintas maneras. En este tema nosotros vamos a explicar dos categorÃ­as o divisiones. La primera divisiÃ³n toma en cuenta una particularidad del algoritmo de bÃºsqueda, si utiliza una funciÃ³n heurÃ­stica o no.

---

### ğŸ” BÃºsqueda no informada

Se dice que una bÃºsqueda es **no informada** cuando no emplea ningÃºn tipo de heurÃ­stica. No hay forma de guiar la bÃºsqueda; siempre se evalÃºa el siguiente estado sin saber si es mejor o peor que el anterior.

### ğŸ’¡ BÃºsqueda informada

En una **bÃºsqueda informada**, los algoritmos emplean una funciÃ³n heurÃ­stica para guiar la bÃºsqueda hacia soluciones Ã³ptimas del problema.

---

### ğŸ§‘â€ğŸ’» Agentes basados en bÃºsquedas

Son aquellos que:
- Mantienen un modelo simbÃ³lico del entorno.
- Quieren modificar el estado del entorno con el fin de alcanzar un estado meta que satisfaga sus objetivos.

---

### ğŸƒâ€â™‚ï¸ Agentes deliberativos y reactivos

- **Deliberativo**: Realiza una bÃºsqueda **offline**, usando todo el tiempo necesario para encontrar una soluciÃ³n.
- **Reactivo**: Realiza una bÃºsqueda **online**, encontrando soluciones parciales mientras ejecuta acciones.

---

## 2. ğŸ› ï¸ Mecanismos para resolver estos problemas

Existen diferentes mecanismos que van desde agentes sin autonomÃ­a hasta aquellos con procesos racionales de toma de decisiones.

### ğŸ² Tablas de actuaciÃ³n

- **Tablas de actuaciÃ³n**: Presentan una secuencia de acciones completas para llegar del estado inicial a un estado final.
- **Flexibilidad**: Se puede mejorar mediante tÃ©cnicas de aprendizaje, pero pueden tener problemas de escalabilidad debido a la memoria.

### ğŸ”§ Algoritmos especÃ­ficos del dominio

- **CodificaciÃ³n especÃ­fica**: El diseÃ±ador del agente crea un algoritmo para resolver un dominio concreto.
- **Problema**: Este enfoque solo sirve para un dominio particular y requiere prever todos los escenarios posibles.

### ğŸ§© MÃ©todos independientes del dominio

- **MÃ©todos generales**: Utilizan un modelo simbÃ³lico del dominio y emplean un algoritmo de bÃºsqueda genÃ©rico.
- **Ventaja**: Mayor flexibilidad al no necesitar conocer la soluciÃ³n previamente.

### ğŸ§³ Problemas de bÃºsqueda en el espacio de estados

- Estos problemas se caracterizan por representar el entorno con un modelo de estados.
- Representado por un grafo, donde cada elemento representa una parte del entorno.
- El objetivo es encontrar el camino mÃ¡s eficiente que lleve del estado inicial al estado meta.
- El agente utiliza su conocimiento a priori para explorar el espacio de estados y encontrar una soluciÃ³n.

### ğŸ§® Algoritmo general de bÃºsqueda

1. **Ãrbol de bÃºsqueda**: Se utiliza un nodo que almacena el estado alcanzado en cada paso.
2. **Lista abierta**: Contiene los nodos a explorar. Si estÃ¡ vacÃ­a, el problema no tiene soluciÃ³n.
3. **Backtracking**: Si se encuentra el nodo meta, se hace un backtracking desde el nodo hasta el estado inicial.
- Se pueden utilizar varias estrategias para evitar ciclos o errores graves:
  - **Ignorarlos**
  - **Evitar ciclos simples**
  - **Evitar ciclos generales**
  - **Evitar todos los estados repetidos**

---

## 3. ğŸŒ³ Busqueda en Amplitud

La ``bÃºsqueda en amplitud (BFS)`` construye un Ã¡rbol de bÃºsqueda ``por niveles``. 

Esto significa que:

1. ğŸ§© Primero explora todos los nodos que se pueden alcanzar en **1 acciÃ³n** desde el estado inicial.
2. ğŸ” Luego, analiza todos los estados alcanzables en **2 acciones**.
3. â¬‡ï¸ DespuÃ©s, los de **3 acciones**, y asÃ­ sucesivamente.

Este orden garantiza que el primer estado meta que se encuentra serÃ¡ el de **menor profundidad**, es decir, el que requiere **menos pasos** desde el inicio.

### ğŸ—‚ï¸ Â¿QuÃ© es un nivel en este contexto?

Un **nivel** corresponde a la cantidad de pasos (acciones) requeridos para llegar a un estado desde el estado inicial:

- Nivel 0: estado inicial.
- Nivel 1: estados alcanzables con 1 acciÃ³n.
- Nivel 2: estados alcanzables con 2 acciones.
- Nivel 3: estados alcanzables con 3 acciones.
- Y asÃ­ sucesivamente...

La exploraciÃ³n por niveles hace que BFS encuentre la **soluciÃ³n mÃ¡s corta** si todas las acciones tienen el mismo costo.

**ğŸ§© Ejemplo: Puzzle-8**

El **Puzzle-8** es un juego que consiste en una **matriz 3x3**, donde hay:
- 8 fichas numeradas del 1 al 8.
- 1 espacio vacÃ­o (representado por `_` o espacio en blanco).

El objetivo es mover las fichas hasta alcanzar una **configuraciÃ³n final deseada**.

### ğŸ¯ Reglas del juego

- Solo se pueden mover las fichas que estÃ©n **al lado** del espacio vacÃ­o.
- Cada movimiento genera un **nuevo estado**.
- Se gana al llegar a la **configuraciÃ³n final objetivo**.

### ğŸ§  Â¿QuÃ© hace BFS aquÃ­?

BFS comienza desde una configuraciÃ³n inicial y genera todos los estados que se pueden alcanzar en **1 movimiento**. Luego analiza todos los estados que se pueden alcanzar en **2 movimientos**, y asÃ­ sucesivamente.

ğŸ” Cada estado nuevo se representa como un **nodo** en un Ã¡rbol de bÃºsqueda.

El algoritmo mantiene dos estructuras principales:

- ğŸŸ¦ **Lista abierta**: contiene los estados que aÃºn deben explorarse. Funciona como una **cola FIFO**

---

## 4. ğŸ•³ï¸ Busquedad en Porfundidad

La **bÃºsqueda en profundidad (DFS, por sus siglas en inglÃ©s)** es otra estrategia de bÃºsqueda **no informada**, es decir, que no utiliza informaciÃ³n adicional sobre el objetivo.

ğŸ” A diferencia de la bÃºsqueda en amplitud, DFS intenta explorar un **camino completo** hasta el final antes de probar con otro.

### ğŸš¶â€â™‚ï¸ Â¿QuÃ© significa esto?

- DFS **desarrolla un solo camino** tan profundo como sea posible.
- Solo si ese camino no lleva al objetivo, retrocede (**backtracking**) y prueba otro camino alternativo.
- AsÃ­, se va expandiendo **de izquierda a derecha** pero **hacia abajo**, profundizando en cada rama antes de probar la siguiente.

---

### ğŸŒ² Â¿CÃ³mo se construye el Ã¡rbol de bÃºsqueda?

Imagina que estÃ¡s caminando por un laberinto:
- En vez de ver todas las opciones posibles desde el inicio (como hace BFS),
- DFS **elige una direcciÃ³n** y la sigue hasta que ya no puede continuar,
- Luego **retrocede** al punto anterior donde tenÃ­a otra opciÃ³n,
- Y **prueba otro camino**.

### ğŸ” AsÃ­ funciona paso a paso:

1. Se toma el nodo inicial.
2. Se expande el **primer sucesor**.
3. Luego se expande el **sucesor del sucesor**, y asÃ­ sucesivamente.
4. Si se llega a un nodo sin hijos, se hace **backtracking** al anterior para probar el siguiente hijo no explorado.

---

### ğŸ§° Mecanismo del algoritmo

DFS usa dos estructuras:

- ğŸŸ¦ **Lista abierta**: donde estÃ¡n los nodos pendientes de explorar. Funciona como una **pila (LIFO)**: el Ãºltimo en entrar es el primero en salir.
- ğŸŸ© **Lista de visitados**: evita revisar el mismo nodo mÃ¡s de una vez en una rama.

### âš™ï¸ Consideraciones clave:

- Los **nuevos sucesores** se aÃ±aden al **inicio** de la lista abierta.
- Siempre se procesa el **Ãºltimo nodo aÃ±adido**, es decir, el **mÃ¡s profundo**.
- Si se llega a un nodo sin hijos, se retrocede al nodo anterior (backtracking).
- Solo se explora un nodo si **no ha sido visitado** en esa rama.

---

### âœ… Ventajas

- **Eficiente en memoria**: solo necesita guardar los nodos en el camino actual.
- Ãštil si se sospecha que la **soluciÃ³n estÃ¡ en lo profundo** del Ã¡rbol.

---

### âš ï¸ Desventajas

- **No es Ã³ptimo**: puede encontrar una soluciÃ³n, pero **no garantiza que sea la mÃ¡s corta**.
- **No siempre es completo**: si hay ciclos o caminos infinitos, podrÃ­a no encontrar la soluciÃ³n sin control de visitados.

---

### ğŸ“Š Complejidad

- â±ï¸ Tiempo: `O(b^m)`  
- ğŸ’¾ Espacio: `O(bm)`

Donde:
- `b` = factor de ramificaciÃ³n (nÃºmero de hijos por nodo).
- `m` = profundidad mÃ¡xima del Ã¡rbol de bÃºsqueda.

---

### ğŸ”„ Resumen comparativo BFS vs DFS

| CaracterÃ­stica       | BFS (Amplitud)        | DFS (Profundidad)                        |
| -------------------- | --------------------- | ---------------------------------------- |
| ğŸ” Tipo de estructura | Cola (FIFO)           | Pila (LIFO)                              |
| ğŸ” ExpansiÃ³n          | Por niveles           | Por ramas profundas                      |
| âœ… Completo           | SÃ­                    | Solo si se evita repetidos               |
| ğŸ¥‡ Ã“ptimo             | SÃ­ (si costo = 1)     | No                                       |
| ğŸ§  Memoria            | Alta                  | Baja                                     |
| ğŸ§¾ Mejor para...      | Soluciones mÃ¡s cortas | Ãrboles profundos o sin soluciÃ³n cercana |

---

## 5. ğŸ’° Busquedad de Coste Uniforme

La **bÃºsqueda de coste uniforme** es una estrategia que se utiliza cuando los costos para transitar de un nodo a otro no son iguales. A diferencia de la **bÃºsqueda en amplitud** y **profundidad**, que asumen que el coste de cada acciÃ³n es igual a 1, este algoritmo tiene en cuenta el **coste real de las transiciones** entre nodos.

### ğŸ” Â¿CÃ³mo se maneja el coste en este algoritmo?

En la **bÃºsqueda de coste uniforme**, el objetivo es encontrar el camino de **menor coste total**. Si cada acciÃ³n tiene un coste diferente, el algoritmo se asegura de **expandir primero** los nodos con el **menor coste acumulado**, en lugar de expandir solo segÃºn el nivel o la profundidad.

---

### ğŸŒ Ejemplo prÃ¡ctico: Encontrar la ruta mÃ¡s corta

Imagina que tenemos un mapa con varias ciudades, y las **carreteras entre las ciudades** tienen diferentes distancias (costos). El objetivo es encontrar la ruta mÃ¡s corta entre dos ciudades.

### ğŸ›£ï¸ Grafo de ejemplo

La figura 19 muestra un **grafo esquemÃ¡tico** de ciudades y carreteras. Cada **arista** entre las ciudades tiene un nÃºmero que representa el **coste** o **distancia** para viajar de una ciudad a otra.

---

### ğŸ”´ Problema en bÃºsquedas de amplitud

En un caso como este, la **bÃºsqueda en amplitud** no es adecuada porque no tiene en cuenta los **costos** de las transiciones. Si aplicamos la bÃºsqueda en amplitud, el algoritmo podrÃ­a elegir un camino subÃ³ptimo, ya que solo se enfoca en expandir los nodos por niveles, sin considerar cuÃ¡nto cuesta cada transiciÃ³n.

### ğŸš¦ Ejemplo de fallo en amplitud:

La figura 20 muestra el resultado de una **bÃºsqueda en amplitud** para encontrar la ruta entre dos ciudades. En este caso, la soluciÃ³n encontrada es **A - S - F - B** (en rojo), que no es la mÃ¡s corta.

La ruta mÃ¡s corta, tomando en cuenta los costos reales de las transiciones, es en realidad **A - S - R - P - B** (en verde).

---

### âš™ï¸ Â¿CÃ³mo funciona el algoritmo de bÃºsqueda de coste uniforme?

Este algoritmo se basa en una **cola de prioridad** donde los nodos con menor coste acumulado son procesados primero. Se sigue el siguiente proceso:

1. **InicializaciÃ³n**: Se coloca el nodo inicial en la cola con un coste de 0.
2. **ExpansiÃ³n**: Se extrae el nodo con el menor coste de la cola y se exploran sus sucesores.
3. **ActualizaciÃ³n de coste**: Si el coste de llegar a un nodo sucesor es menor que el previamente registrado, se actualiza y se agrega a la cola de prioridad.
4. **Repetir**: Este proceso se repite hasta encontrar el nodo meta con el **menor coste** posible.

---

### ğŸ“ˆ Complejidad

- â±ï¸ **Tiempo**: El algoritmo de bÃºsqueda de coste uniforme tiene una **complejidad de tiempo** de `O((b^d) log b)`, donde `b` es el factor de ramificaciÃ³n y `d` la profundidad del Ã¡rbol.
- ğŸ’¾ **Espacio**: Su **complejidad espacial** tambiÃ©n es `O(b^d)` debido al almacenamiento de nodos en la cola de prioridad.

---

### âœ… Ventajas

- **Ã“ptimo**: Siempre encuentra la soluciÃ³n de menor coste si existe.
- **Completo**: Garantiza encontrar una soluciÃ³n si el espacio de bÃºsqueda es finito.

---

### âš ï¸ Desventajas

- **Lento**: Puede ser muy lento y consumir mucha memoria, especialmente en problemas grandes con muchos nodos.
- **Requiere mÃ¡s recursos**: Debido al uso de una cola de prioridad, puede ser mÃ¡s costoso en tÃ©rminos de espacio y tiempo de ejecuciÃ³n comparado con otros algoritmos.

---

## ğŸ› ï¸ ComparaciÃ³n de la bÃºsqueda de coste uniforme con otros algoritmos

| CaracterÃ­stica        | BÃºsqueda de coste uniforme    | BÃºsqueda en amplitud           | BÃºsqueda en profundidad                |
| --------------------- | ----------------------------- | ------------------------------ | -------------------------------------- |
| ğŸ” Tipo de bÃºsqueda    | Basado en coste               | Por niveles                    | Por profundidad                        |
| âœ… Ã“ptimo              | SÃ­                            | SÃ­ (si los costos son iguales) | No                                     |
| ğŸ§  Completo            | SÃ­                            | SÃ­                             | SÃ­ (si se controlan ciclos)            |
| ğŸ’¾ Uso de memoria      | Alto (cola de prioridad)      | Moderado (cola)                | Bajo                                   |
| â±ï¸ Tiempo de ejecuciÃ³n | Lento                         | RÃ¡pido (sin costos)            | Puede ser muy rÃ¡pido (con pocos nodos) |
| ğŸ›£ï¸ Mejor para...       | Problemas con costes variados | Soluciones de menor nivel      | Problemas con soluciones profundas     |

---

